(()=>{"use strict";var e,t,n,i,s;function o(e){return e.type===n.OBJECT&&!function(e){return void 0!==e.parentId&&void 0!==e.parentKey}(e)}!function(e){e[e.UPDATE_PRESENCE=100]="UPDATE_PRESENCE",e[e.USER_JOINED=101]="USER_JOINED",e[e.USER_LEFT=102]="USER_LEFT",e[e.BROADCASTED_EVENT=103]="BROADCASTED_EVENT",e[e.ROOM_STATE=104]="ROOM_STATE",e[e.INITIAL_STORAGE_STATE=200]="INITIAL_STORAGE_STATE",e[e.UPDATE_STORAGE=201]="UPDATE_STORAGE"}(e||(e={})),function(e){e[e.UPDATE_PRESENCE=100]="UPDATE_PRESENCE",e[e.BROADCAST_EVENT=103]="BROADCAST_EVENT",e[e.FETCH_STORAGE=200]="FETCH_STORAGE",e[e.UPDATE_STORAGE=201]="UPDATE_STORAGE"}(t||(t={})),function(e){e[e.OBJECT=0]="OBJECT",e[e.LIST=1]="LIST",e[e.MAP=2]="MAP",e[e.REGISTER=3]="REGISTER"}(n||(n={})),function(e){e[e.INIT=0]="INIT",e[e.SET_PARENT_KEY=1]="SET_PARENT_KEY",e[e.CREATE_LIST=2]="CREATE_LIST",e[e.UPDATE_OBJECT=3]="UPDATE_OBJECT",e[e.CREATE_OBJECT=4]="CREATE_OBJECT",e[e.DELETE_CRDT=5]="DELETE_CRDT",e[e.DELETE_OBJECT_KEY=6]="DELETE_OBJECT_KEY",e[e.CREATE_MAP=7]="CREATE_MAP",e[e.CREATE_REGISTER=8]="CREATE_REGISTER"}(i||(i={})),function(e){e[e.CLOSE_ABNORMAL=1006]="CLOSE_ABNORMAL",e[e.INVALID_MESSAGE_FORMAT=4e3]="INVALID_MESSAGE_FORMAT",e[e.NOT_ALLOWED=4001]="NOT_ALLOWED",e[e.MAX_NUMBER_OF_MESSAGES_PER_SECONDS=4002]="MAX_NUMBER_OF_MESSAGES_PER_SECONDS",e[e.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS=4003]="MAX_NUMBER_OF_CONCURRENT_CONNECTIONS",e[e.MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP=4004]="MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP",e[e.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM=4005]="MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM",e[e.CLOSE_WITHOUT_RETRY=4999]="CLOSE_WITHOUT_RETRY"}(s||(s={}));class r{get _doc(){return this.__doc}get roomId(){return this.__doc?this.__doc.roomId:null}get _id(){return this.__id}get _parent(){return this.__parent}get _parentKey(){return this.__parentKey}_apply(e,t){return e.type===i.DELETE_CRDT&&null!=this._parent&&null!=this._parentKey?this._parent._detachChild(this):{modified:!1}}_setParentLink(e,t){if(null!=this.__parent&&this.__parent!==e)throw new Error("Cannot attach parent if it already exist");this.__parentKey=t,this.__parent=e}_attach(e,t){if(this.__id||this.__doc)throw new Error("Cannot attach if CRDT is already attached");t.addItem(e,this),this.__id=e,this.__doc=t}_detach(){this.__doc&&this.__id&&this.__doc.deleteItem(this.__id),this.__parent=void 0,this.__doc=void 0}}function a(e){return Array.isArray(e)}function c(e){return!function(e){return null===e||"string"==typeof e||"number"==typeof e||"boolean"==typeof e}(e)&&!a(e)}class d extends r{constructor(e){super(),this._data=e}get data(){return this._data}static _deserialize([e,t],n,i){const s=new d(t.data);return s._attach(e,i),s}_serialize(e,t,n,s){if(null==this._id||null==e||null==t)throw new Error("Cannot serialize register if parentId or parentKey is undefined");return[{type:i.CREATE_REGISTER,opId:null==n?void 0:n.generateOpId(),id:this._id,intent:s,parentId:e,parentKey:t,data:this.data}]}_toSerializedCrdt(){var e;return{type:n.REGISTER,parentId:null===(e=this._parent)||void 0===e?void 0:e._id,parentKey:this._parentKey,data:this.data}}_attachChild(e,t){throw new Error("Method not implemented.")}_detachChild(e){throw new Error("Method not implemented.")}_apply(e,t){return super._apply(e,t)}}function u(e,t){return null==e&&null==t?p([33]):null!=e&&null==t?function(e){const t=[],n=h(e);for(let e=0;e<n.length;e++){const i=n[e];if(126!==i){t.push(i+1);break}if(t.push(i),n.length-1===e){t.push(33);break}}return p(t)}(e):null==e&&null!=t?function(e){const t=[],n=h(e);for(let e=0;e<n.length;e++){const i=n[e];if(!(i<=33)){t.push(i-1);break}if(t.push(32),n.length-1===e){t.push(126);break}}return p(t)}(t):p(l(h(e),h(t)))}function l(e,t){let n=0;const i=[];for(;;){const s=e[n]||32,o=t[n]||126;if(s>o)throw new Error(`Impossible to generate position between ${e} and ${t}`);if(s===o){i.push(s),n++;continue}if(o-s==1){i.push(s),i.push(...l(e.slice(n+1),[]));break}const r=o+s>>1;i.push(r);break}return i}function h(e){const t=[];for(let n=0;n<e.length;n++)t.push(e.charCodeAt(n));return t}function p(e){return String.fromCharCode(...e)}function _(e,t){const n=h(e),i=h(t),s=Math.max(n.length,i.length);for(let e=0;e<s;e++){const t=null==n[e]?32:n[e],s=null==i[e]?32:i[e];if(t!==s)return t-s}throw new Error(`Impossible to compare similar position "${e}" and "${t}"`)}class f extends r{constructor(e=[]){let t;super(),this._items=[];for(let n=0;n<e.length;n++){const i=u(t),s=w(e[n]);this._items.push([s,i]),t=i}}static _deserialize([e],t,n){const i=new f([]);i._attach(e,n);const s=t.get(e);if(null==s)return i;for(const e of s){const s=b(e,t,n);s._setParentLink(i,e[1].parentKey),i._items.push([s,e[1].parentKey]),i._items.sort(((e,t)=>_(e[1],t[1])))}return i}_serialize(e,t,n,s){if(null==this._id)throw new Error("Cannot serialize item is not attached");if(null==e||null==t)throw new Error("Cannot serialize list if parentId or parentKey is undefined");const o=[],r={id:this._id,opId:null==n?void 0:n.generateOpId(),intent:s,type:i.CREATE_LIST,parentId:e,parentKey:t};o.push(r);for(const[e,t]of this._items)o.push(...e._serialize(this._id,t,n));return o}_indexOfPosition(e){return this._items.findIndex((t=>t[1]===e))}_attach(e,t){super._attach(e,t);for(const[e]of this._items)e._attach(t.generateId(),t)}_detach(){super._detach();for(const[e]of this._items)e._detach()}_attachChild(e,t){var n;if(null==this._doc)throw new Error("Can't attach child if doc is not present");const{id:s,parentKey:o,intent:r}=e,a=o,c=g(e);if(void 0!==this._doc.getItem(s))return{modified:!1};c._attach(s,this._doc),c._setParentLink(this,a);const l=this._items.findIndex((e=>e[1]===a));let h=a;if(-1!==l){if("set"===r){const e=this._items[l][0];e._detach();const t={node:this,type:"LiveList",updates:[{index:l,type:"set",item:c instanceof d?c.data:c}]};return this._items[l][0]=c,{modified:t,reverse:e._serialize(this._id,a,this._doc,"set")}}if(t){const e=this._items[l]?this._items[l][1]:void 0,t=this._items[l+1]?this._items[l+1][1]:void 0;h=u(e,t),c._setParentLink(this,h)}else this._items[l][1]=u(a,null===(n=this._items[l+1])||void 0===n?void 0:n[1])}this._items.push([c,h]),this._items.sort(((e,t)=>_(e[1],t[1])));const p=this._items.findIndex((e=>e[1]===h));return{reverse:[{type:i.DELETE_CRDT,id:s}],modified:{node:this,type:"LiveList",updates:[{index:p,type:"insert",item:c instanceof d?c.data:c}]}}}_detachChild(e){if(e){const t=e._serialize(this._id,e._parentKey,this._doc),n=this._items.findIndex((t=>t[0]===e));return this._items.splice(n,1),e._detach(),{modified:{node:this,type:"LiveList",updates:[{index:n,type:"delete"}]},reverse:t}}return{modified:!1}}_setChildKey(e,t,n){var s;t._setParentLink(this,e);const o=this._items.findIndex((e=>e[0]._id===t._id)),r=this._items.findIndex((t=>t[1]===e));-1!==r&&(this._items[r][1]=u(e,null===(s=this._items[r+1])||void 0===s?void 0:s[1]));const a=this._items.find((e=>e[0]===t));a&&(a[1]=e),this._items.sort(((e,t)=>_(e[1],t[1])));const c=this._items.findIndex((e=>e[0]._id===t._id));return{modified:{node:this,type:"LiveList",updates:c===o?[]:[{index:c,item:t instanceof d?t.data:t,previousIndex:o,type:"move"}]},reverse:[{type:i.SET_PARENT_KEY,id:null==a?void 0:a[0]._id,parentKey:n}]}}_apply(e,t){return super._apply(e,t)}_toSerializedCrdt(){var e;return{type:n.LIST,parentId:null===(e=this._parent)||void 0===e?void 0:e._id,parentKey:this._parentKey}}get length(){return this._items.length}push(e){return this.insert(e,this.length)}insert(e,t){if(t<0||t>this._items.length)throw new Error(`Cannot insert list item at index "${t}". index should be between 0 and ${this._items.length}`);const n=u(this._items[t-1]?this._items[t-1][1]:void 0,this._items[t]?this._items[t][1]:void 0),s=w(e);s._setParentLink(this,n),this._items.push([s,n]),this._items.sort(((e,t)=>_(e[1],t[1])));const o=this._items.findIndex((e=>e[1]===n));if(this._doc&&this._id){const e=this._doc.generateId();s._attach(e,this._doc);const t=new Map;t.set(this._id,{node:this,type:"LiveList",updates:[{index:o,item:s instanceof d?s.data:s,type:"insert"}]}),this._doc.dispatch(s._serialize(this._id,n,this._doc),[{type:i.DELETE_CRDT,id:e}],t)}}move(e,t){if(t<0)throw new Error("targetIndex cannot be less than 0");if(t>=this._items.length)throw new Error("targetIndex cannot be greater or equal than the list length");if(e<0)throw new Error("index cannot be less than 0");if(e>=this._items.length)throw new Error("index cannot be greater or equal than the list length");let n=null,s=null;e<t?(s=t===this._items.length-1?void 0:this._items[t+1][1],n=this._items[t][1]):(s=this._items[t][1],n=0===t?void 0:this._items[t-1][1]);const o=u(n,s),r=this._items[e],a=r[1];r[1]=o,r[0]._setParentLink(this,o),this._items.sort(((e,t)=>_(e[1],t[1])));const c=this._items.findIndex((e=>e[1]===o));if(this._doc&&this._id){const t=new Map;t.set(this._id,{node:this,type:"LiveList",updates:[{index:c,previousIndex:e,item:r[0],type:"move"}]}),this._doc.dispatch([{type:i.SET_PARENT_KEY,id:r[0]._id,opId:this._doc.generateOpId(),parentKey:o}],[{type:i.SET_PARENT_KEY,id:r[0]._id,parentKey:a}],t)}}delete(e){if(e<0||e>=this._items.length)throw new Error(`Cannot delete list item at index "${e}". index should be between 0 and ${this._items.length-1}`);const t=this._items[e];if(t[0]._detach(),this._items.splice(e,1),this._doc){const n=t[0]._id;if(n){const s=new Map;s.set(this._id,{node:this,type:"LiveList",updates:[{index:e,type:"delete"}]}),this._doc.dispatch([{id:n,opId:this._doc.generateOpId(),type:i.DELETE_CRDT}],t[0]._serialize(this._id,t[1]),s)}}}clear(){if(this._doc){const e=[],t=[],n=[];let s=0;for(const o of this._items){o[0]._detach();const r=o[0]._id;r&&(e.push({id:r,type:i.DELETE_CRDT}),t.push(...o[0]._serialize(this._id,o[1])),n.push({index:s,type:"delete"})),s++}this._items=[];const o=new Map;o.set(this._id,{node:this,type:"LiveList",updates:n}),this._doc.dispatch(e,t,o)}else{for(const e of this._items)e[0]._detach();this._items=[]}}set(e,t){if(e<0||e>=this._items.length)throw new Error(`Cannot set list item at index "${e}". index should be between 0 and ${this._items.length-1}`);const[n,i]=this._items[e];n._detach();const s=w(t);if(s._setParentLink(this,i),this._items[e][0]=s,this._doc&&this._id){const t=this._doc.generateId();s._attach(t,this._doc);const o=new Map;o.set(this._id,{node:this,type:"LiveList",updates:[{index:e,item:s instanceof d?s.data:s,type:"set"}]}),this._doc.dispatch(s._serialize(this._id,i,this._doc,"set"),n._serialize(this._id,i,void 0,"set"),o)}}toArray(){return this._items.map((e=>I(e[0])))}every(e){return this.toArray().every(e)}filter(e){return this.toArray().filter(e)}find(e){return this.toArray().find(e)}findIndex(e){return this.toArray().findIndex(e)}forEach(e){return this.toArray().forEach(e)}get(e){if(!(e<0||e>=this._items.length))return I(this._items[e][0])}indexOf(e,t){return this.toArray().indexOf(e,t)}lastIndexOf(e,t){return this.toArray().lastIndexOf(e,t)}map(e){return this._items.map(((t,n)=>e(I(t[0]),n)))}some(e){return this.toArray().some(e)}[Symbol.iterator](){return new E(this._items)}}class E{constructor(e){this._innerIterator=e[Symbol.iterator]()}[Symbol.iterator](){return this}next(){const e=this._innerIterator.next();return e.done?{done:!0,value:void 0}:{value:I(e.value[0])}}}new Set;class m extends r{constructor(e){if(super(),e){const t=[];for(const n of e){const e=w(n[1]);e._setParentLink(this,n[0]),t.push([n[0],e])}this._map=new Map(t)}else this._map=new Map}_serialize(e,t,n,s){if(null==this._id)throw new Error("Cannot serialize item is not attached");if(null==e||null==t)throw new Error("Cannot serialize map if parentId or parentKey is undefined");const o=[],r={id:this._id,opId:null==n?void 0:n.generateOpId(),type:i.CREATE_MAP,intent:s,parentId:e,parentKey:t};o.push(r);for(const[e,t]of this._map)o.push(...t._serialize(this._id,e,n));return o}static _deserialize([e,t],n,i){const s=new m;s._attach(e,i);const o=n.get(e);if(null==o)return s;for(const e of o){const t=e[1];if(null==t.parentKey)throw new Error("Tried to deserialize a crdt but it does not have a parentKey and is not the root");const o=b(e,n,i);o._setParentLink(s,t.parentKey),s._map.set(t.parentKey,o)}return s}_attach(e,t){super._attach(e,t);for(const[e,n]of this._map)O(n)&&n._attach(t.generateId(),t)}_attachChild(e,t){if(null==this._doc)throw new Error("Can't attach child if doc is not present");const{id:n,parentKey:s}=e,o=s,r=g(e);if(void 0!==this._doc.getItem(n))return{modified:!1};const a=this._map.get(o);let c;return a?(c=a._serialize(this._id,o),a._detach()):c=[{type:i.DELETE_CRDT,id:n}],r._setParentLink(this,o),r._attach(n,this._doc),this._map.set(o,r),{modified:{node:this,type:"LiveMap",updates:{[o]:{type:"update"}}},reverse:c}}_detach(){super._detach();for(const e of this._map.values())e._detach()}_detachChild(e){const t=e._serialize(this._id,e._parentKey,this._doc);for(const[t,n]of this._map)n===e&&this._map.delete(t);return e._detach(),{modified:{node:this,type:"LiveMap",updates:{[e._parentKey]:{type:"delete"}}},reverse:t}}_toSerializedCrdt(){var e;return{type:n.MAP,parentId:null===(e=this._parent)||void 0===e?void 0:e._id,parentKey:this._parentKey}}get(e){const t=this._map.get(e);if(null!=t)return I(t)}set(e,t){const n=this._map.get(e);n&&n._detach();const s=w(t);if(s._setParentLink(this,e),this._map.set(e,s),this._doc&&this._id){const t=this._doc.generateId();s._attach(t,this._doc);const o=new Map;o.set(this._id,{node:this,type:"LiveMap",updates:{[e]:{type:"update"}}}),this._doc.dispatch(s._serialize(this._id,e,this._doc),n?n._serialize(this._id,e):[{type:i.DELETE_CRDT,id:t}],o)}}get size(){return this._map.size}has(e){return this._map.has(e)}delete(e){const t=this._map.get(e);if(null==t)return!1;if(t._detach(),this._map.delete(e),this._doc&&t._id){const n=new Map;n.set(this._id,{node:this,type:"LiveMap",updates:{[e]:{type:"delete"}}}),this._doc.dispatch([{type:i.DELETE_CRDT,id:t._id,opId:this._doc.generateOpId()}],t._serialize(this._id,e),n)}return!0}entries(){const e=this._map.entries();return{[Symbol.iterator]:function(){return this},next(){const t=e.next();return t.done?{done:!0,value:void 0}:{value:[t.value[0],I(t.value[1])]}}}}[Symbol.iterator](){return this.entries()}keys(){return this._map.keys()}values(){const e=this._map.values();return{[Symbol.iterator]:function(){return this},next(){const t=e.next();return t.done?{done:!0,value:void 0}:{value:I(t.value)}}}}forEach(e){for(const t of this)e(t[1],t[0],this)}}function y(e,t){for(let n=0;n<e.length;n++)if(e[n]===t){e.splice(n,1);break}}function T(e){return e.filter((e=>null!=e))}function g(e){switch(e.type){case i.CREATE_REGISTER:return new d(e.data);case i.CREATE_OBJECT:return new A(e.data);case i.CREATE_MAP:return new m;case i.CREATE_LIST:return new f}}function v(e,t){return e===t||!!e._parent&&v(e._parent,t)}function b([e,t],i,s){switch(t.type){case n.OBJECT:return A._deserialize([e,t],i,s);case n.LIST:return f._deserialize([e,t],i,s);case n.MAP:return m._deserialize([e,t],i,s);case n.REGISTER:return d._deserialize([e,t],i,s);default:throw new Error("Unexpected CRDT type")}}function O(e){return e instanceof A||e instanceof m||e instanceof f||e instanceof d}function I(e){return e instanceof d?e.data:e}function w(e){if(e instanceof A||e instanceof m||e instanceof f)return e;if(e instanceof d)throw new Error("Internal error. LiveRegister should not be created from selfOrRegister");return new d(e)}function C(e,t){return e?"LiveObject"===e.type&&"LiveObject"===t.type?function(e,t){const n=e.updates;for(const[e,i]of R(t.updates))n[e]=i;return Object.assign(Object.assign({},t),{updates:n})}(e,t):"LiveMap"===e.type&&"LiveMap"===t.type?function(e,t){const n=e.updates;for(const[e,i]of R(t.updates))n[e]=i;return Object.assign(Object.assign({},t),{updates:n})}(e,t):"LiveList"===e.type&&"LiveList"===t.type?function(e,t){const n=e.updates;return Object.assign(Object.assign({},t),{updates:n.concat(t.updates)})}(e,t):t:t}function R(e){return Object.entries(e)}function S(e){try{return JSON.parse(e)}catch(e){return}}class A extends r{constructor(e={}){super(),this._propToLastUpdate=new Map;for(const t in e){const n=e[t];n instanceof r&&n._setParentLink(this,t)}this._map=new Map(Object.entries(e))}_serialize(e,t,n,s){if(null==this._id)throw new Error("Cannot serialize item is not attached");const o=null==n?void 0:n.generateOpId(),a=[],c=void 0!==e&&void 0!==t?{type:i.CREATE_OBJECT,id:this._id,opId:o,intent:s,parentId:e,parentKey:t,data:{}}:{type:i.CREATE_OBJECT,id:this._id,opId:o,intent:s,data:{}};a.push(c);for(const[e,t]of this._map)t instanceof r?a.push(...t._serialize(this._id,e,n)):c.data[e]=t;return a}static _deserialize([e,t],n,i){const s=new A(t.data);return s._attach(e,i),this._deserializeChildren(s,n,i)}static _deserializeChildren(e,t,n){const i=t.get(e._id);if(null==i)return e;for(const s of i){const i=s[1];if(null==i.parentKey)throw new Error("Tried to deserialize a crdt but it does not have a parentKey and is not the root");const o=b(s,t,n);o._setParentLink(e,i.parentKey),e._map.set(i.parentKey,o)}return e}_attach(e,t){super._attach(e,t);for(const[e,n]of this._map)n instanceof r&&n._attach(t.generateId(),t)}_attachChild(e,t){if(null==this._doc)throw new Error("Can't attach child if doc is not present");const{id:n,parentKey:s,opId:o}=e,r=s,a=g(e);if(void 0!==this._doc.getItem(n))return this._propToLastUpdate.get(r)===o&&this._propToLastUpdate.delete(r),{modified:!1};if(t)this._propToLastUpdate.set(r,o);else if(void 0!==this._propToLastUpdate.get(r))return this._propToLastUpdate.get(r)===o?(this._propToLastUpdate.delete(r),{modified:!1}):{modified:!1};const c=this._map.get(r);let d;return O(c)?(d=c._serialize(this._id,r),c._detach()):d=void 0===c?[{type:i.DELETE_OBJECT_KEY,id:this._id,key:r}]:[{type:i.UPDATE_OBJECT,id:this._id,data:{[r]:c}}],this._map.set(r,a),a._setParentLink(this,r),a._attach(n,this._doc),{reverse:d,modified:{node:this,type:"LiveObject",updates:{[r]:{type:"update"}}}}}_detachChild(e){if(e){const t=e._serialize(this._id,e._parentKey,this._doc);for(const[t,n]of this._map)n===e&&this._map.delete(t);return e._detach(),{modified:{node:this,type:"LiveObject",updates:{[e._parentKey]:{type:"delete"}}},reverse:t}}return{modified:!1}}_detachChildren(){for(const[e,t]of this._map)this._map.delete(e),t._detach()}_detach(){super._detach();for(const e of this._map.values())O(e)&&e._detach()}_apply(e,t){return e.type===i.UPDATE_OBJECT?this._applyUpdate(e,t):e.type===i.DELETE_OBJECT_KEY?this._applyDeleteObjectKey(e):super._apply(e,t)}_toSerializedCrdt(){var e;const t={};for(const[e,n]of this._map)n instanceof r==0&&(t[e]=n);return void 0!==(null===(e=this._parent)||void 0===e?void 0:e._id)&&void 0!==this._parentKey?{type:n.OBJECT,parentId:this._parent._id,parentKey:this._parentKey,data:t}:{type:n.OBJECT,data:t}}_applyUpdate(e,t){let n=!1;const s=[],o={type:i.UPDATE_OBJECT,id:this._id,data:{}};s.push(o);for(const t in e.data){const e=this._map.get(t);e instanceof r?(s.push(...e._serialize(this._id,t)),e._detach()):void 0!==e?o.data[t]=e:void 0===e&&s.push({type:i.DELETE_OBJECT_KEY,id:this._id,key:t})}const a={};for(const i in e.data){if(t)this._propToLastUpdate.set(i,e.opId);else{if(null!=this._propToLastUpdate.get(i)){if(this._propToLastUpdate.get(i)===e.opId){this._propToLastUpdate.delete(i);continue}continue}n=!0}const s=this._map.get(i);O(s)&&s._detach(),n=!0,a[i]={type:"update"},this._map.set(i,e.data[i])}return 0!==Object.keys(o.data).length&&s.unshift(o),n?{modified:{node:this,type:"LiveObject",updates:a},reverse:s}:{modified:!1}}_applyDeleteObjectKey(e){const t=e.key;if(!1===this._map.has(t))return{modified:!1};if(void 0!==this._propToLastUpdate.get(t))return{modified:!1};const n=this._map.get(t);let s=[];return O(n)?(s=n._serialize(this._id,e.key),n._detach()):void 0!==n&&(s=[{type:i.UPDATE_OBJECT,id:this._id,data:{[t]:n}}]),this._map.delete(t),{modified:{node:this,type:"LiveObject",updates:{[e.key]:{type:"delete"}}},reverse:s}}toObject(){return function(e){const t={};for(const[n,i]of e)t[n]=i;return t}(this._map)}set(e,t){this.update({[e]:t})}get(e){return this._map.get(e)}delete(e){const t=e,n=this._map.get(t);if(void 0===n)return;if(null==this._doc||null==this._id)return n instanceof r&&n._detach(),void this._map.delete(t);let s;n instanceof r?(n._detach(),s=n._serialize(this._id,t)):s=[{type:i.UPDATE_OBJECT,data:{[t]:n},id:this._id}],this._map.delete(t);const o=new Map;o.set(this._id,{node:this,type:"LiveObject",updates:{[e]:{type:"delete"}}}),this._doc.dispatch([{type:i.DELETE_OBJECT_KEY,key:t,id:this._id,opId:this._doc.generateOpId()}],s,o)}update(e){if(null==this._doc||null==this._id){for(const t in e){const n=this._map.get(t);n instanceof r&&n._detach();const i=e[t];i instanceof r&&i._setParentLink(this,t),this._map.set(t,i)}return}const t=[],n=[],s=this._doc.generateOpId(),o={},a={id:this._id,type:i.UPDATE_OBJECT,data:{}},c={};for(const d in e){const u=this._map.get(d);u instanceof r?(n.push(...u._serialize(this._id,d)),u._detach()):void 0===u?n.push({type:i.DELETE_OBJECT_KEY,id:this._id,key:d}):a.data[d]=u;const l=e[d];if(l instanceof r){l._setParentLink(this,d),l._attach(this._doc.generateId(),this._doc);const e=l._serialize(this._id,d,this._doc),n=e.find((e=>e.parentId===this._id));n&&this._propToLastUpdate.set(d,n.opId),t.push(...e)}else o[d]=l,this._propToLastUpdate.set(d,s);this._map.set(d,l),c[d]={type:"update"}}0!==Object.keys(a.data).length&&n.unshift(a),0!==Object.keys(o).length&&t.unshift({opId:s,id:this._id,type:i.UPDATE_OBJECT,data:o});const d=new Map;d.set(this._id,{node:this,type:"LiveObject",updates:c}),this._doc.dispatch(t,n,d)}}const L=[250,500,1e3,2e3,4e3,8e3,1e4],k=[2e3,3e4,6e4,3e5];function P(e){return"my-presence"===e||"others"===e||"event"===e||"error"===e||"connection"===e}function D(e){const t=Object.values(e).map((e=>function(e,t){var n={};for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.indexOf(i)<0&&(n[i]=e[i]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(i=Object.getOwnPropertySymbols(e);s<i.length;s++)t.indexOf(i[s])<0&&Object.prototype.propertyIsEnumerable.call(e,i[s])&&(n[i[s]]=e[i[s]])}return n}(e,["_hasReceivedInitialPresence"])));return{get count(){return t.length},[Symbol.iterator]:()=>t[Symbol.iterator](),map:e=>t.map(e),toArray:()=>t}}class K extends Error{constructor(e,t){super(e),this.code=t}}function N(e){const t=e.split(".");if(3!==t.length)throw new Error("Authentication error. Liveblocks could not parse the response of your authentication endpoint");const n=S(function(e){try{const t=e.replace(/-/g,"+").replace(/_/g,"/");return decodeURIComponent(atob(t).split("").map((function(e){return"%"+("00"+e.charCodeAt(0).toString(16)).slice(-2)})).join(""))}catch(t){return atob(e)}}(t[1]));if(void 0!==n&&c(n)&&"number"==typeof n.actor&&(void 0===n.id||"string"==typeof n.id))return{actor:n.actor,id:n.id,info:n.info};throw new Error("Authentication error. Liveblocks could not parse the response of your authentication endpoint")}function U(e,t,n){return e(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)}).then((e=>{if(!e.ok)throw new M(`Expected a status 200 but got ${e.status} when doing a POST request on "${t}"`);return e.json().catch((e=>{throw new M(`Expected a json when doing a POST request on "${t}". ${e}`)}))})).then((e=>{if("string"!=typeof e.token)throw new M(`Expected a json with a string token when doing a POST request on "${t}", but got ${JSON.stringify(e)}`);return e}))}class M extends Error{constructor(e){super(e)}}function B(d){const u=d,l=function(e){if(void 0===e.throttle)return 100;if("number"!=typeof e.throttle||e.throttle<80||e.throttle>1e3)throw new Error("throttle should be a number between 80 and 1000.");return e.throttle}(d),h=new Map;return"undefined"!=typeof window&&window.addEventListener("online",(()=>{for(const[,e]of h)e.onNavigatorOnline()})),"undefined"!=typeof document&&document.addEventListener("visibilitychange",(()=>{for(const[,e]of h)e.onVisibilityChange(document.visibilityState)})),{getRoom:function(e){const t=h.get(e);return t?t.room:null},enter:function(d,p={}){let _=h.get(d);return _||(p.defaultPresence,p.defaultStorageRoot,_=function(d,u){var l,h;const p=null!==(l=d.initialPresence)&&void 0!==l?l:d.defaultPresence,_=null!==(h=d.initialStorage)&&void 0!==h?h:d.defaultStorageRoot,E=function(d,u,l){const h=l||{authenticate(e,t){const n=d.token;if(!n||!function(e){const t=e.split(".");if(3!==t.length)return!1;const n=S(atob(t[1]));return!(void 0===n||!c(n)||"number"!=typeof n.exp||Date.now()/1e3>n.exp-300)}(n))return e(u.roomId).then((({token:e})=>{"authenticating"===d.connection.state&&(H(N(e),t(e)),d.token=e)})).catch((e=>(d.token=null,X({state:"unavailable"}),d.numberOfRetry++,void(d.timeoutHandles.reconnect=h.scheduleReconnect(q())))));H(N(n),t(n))},send(e){if(null==d.socket)throw new Error("Can't send message if socket is null");d.socket.send(JSON.stringify(e))},delayFlush:e=>setTimeout(se,e),startHeartbeatInterval:()=>setInterval(ee,3e4),schedulePongTimeout:()=>setTimeout(te,2e3),scheduleReconnect:e=>setTimeout(z,e)};function p(e){return d.listeners.storage.push(e),()=>y(d.listeners.storage,e)}function _(e){if(0===e.items.length)throw new Error("Internal error: cannot load storage without items");d.root?function(e){if(!d.root)return;const t=new Map;d.items.forEach(((e,n)=>{t.set(n,e._toSerializedCrdt())}));const s=function(e,t){const s=[];return e.forEach(((e,n)=>{t.get(n)||s.push({type:i.DELETE_CRDT,id:n})})),t.forEach(((t,o)=>{const r=e.get(o);if(r)t.type===n.OBJECT&&(r.type===n.OBJECT&&JSON.stringify(t.data)===JSON.stringify(r.data)||s.push({type:i.UPDATE_OBJECT,id:o,data:t.data})),t.parentKey!==r.parentKey&&s.push({type:i.SET_PARENT_KEY,id:o,parentKey:t.parentKey});else switch(t.type){case n.REGISTER:s.push({type:i.CREATE_REGISTER,id:o,parentId:t.parentId,parentKey:t.parentKey,data:t.data});break;case n.LIST:s.push({type:i.CREATE_LIST,id:o,parentId:t.parentId,parentKey:t.parentKey});break;case n.OBJECT:s.push(t.parentId?{type:i.CREATE_OBJECT,id:o,parentId:t.parentId,parentKey:t.parentKey,data:t.data}:{type:i.CREATE_OBJECT,id:o,data:t.data});break;case n.MAP:s.push({type:i.CREATE_MAP,id:o,parentId:t.parentId,parentKey:t.parentKey})}})),s}(t,new Map(e));I(B(s,!1).updates)}(e.items):d.root=function(e){const[t,n]=function(e){const t=new Map;let n=null;for(const[i,s]of e)if(o(s))n=[i,s];else{const e=[i,s],n=t.get(s.parentId);null!=n?n.push(e):t.set(s.parentId,[e])}if(null==n)throw new Error("Root can't be null");return[n,t]}(e);return A._deserialize(t,n,{getItem:g,addItem:E,deleteItem:m,generateId:R,generateOpId:M,dispatch:O,roomId:u.roomId})}(e.items);for(const e in d.defaultStorageRoot)null==d.root.get(e)&&d.root.set(e,d.defaultStorageRoot[e])}function E(e,t){d.items.set(e,t)}function m(e){d.items.delete(e)}function g(e){return d.items.get(e)}function b(e){d.undoStack.length>=50&&d.undoStack.shift(),d.isHistoryPaused?d.pausedHistory.unshift(...e):d.undoStack.push(e)}function O(e,t,n){d.isBatching?(d.batch.ops.push(...e),n.forEach(((e,t)=>{d.batch.updates.storageUpdates.set(t,C(d.batch.updates.storageUpdates.get(t),e))})),d.batch.reverseOps.push(...t)):(b(t),d.redoStack=[],re(e),I({storageUpdates:n}))}function I({storageUpdates:e=new Map,presence:t=!1,others:n=[]}){if(n.length>0){d.others=D(d.users);for(const e of n)for(const t of d.listeners.others)t(d.others,e)}if(t)for(const e of d.listeners["my-presence"])e(d.me);if(e.size>0)for(const t of d.listeners.storage)t(Array.from(e.values()))}function w(){if("open"===d.connection.state||"connecting"===d.connection.state)return d.connection.id;if(null!==d.lastConnectionId)return d.lastConnectionId;throw new Error("Internal. Tried to get connection id but connection was never open")}function R(){return`${w()}:${d.clock++}`}function M(){return`${w()}:${d.opClock++}`}function B(e,t){var n;const s={reverse:[],updates:{storageUpdates:new Map,presence:!1}},o=new Set;for(const r of e)if("presence"===r.type){const e={type:"presence",data:{}};for(const t in r.data)e.data[t]=d.me[t];if(d.me=Object.assign(Object.assign({},d.me),r.data),null==d.buffer.presence)d.buffer.presence=r.data;else for(const e in r.data)d.buffer.presence[e]=r.data[e];s.reverse.unshift(e),s.updates.presence=!0}else{t&&!r.opId&&(r.opId=M());const e=x(r,t);if(e.modified){const t=null===(n=e.modified.node._parent)||void 0===n?void 0:n._id;o.has(t)||(s.updates.storageUpdates.set(e.modified.node._id,C(s.updates.storageUpdates.get(e.modified.node._id),e.modified)),s.reverse.unshift(...e.reverse)),r.type!==i.CREATE_LIST&&r.type!==i.CREATE_MAP&&r.type!==i.CREATE_OBJECT||o.add(e.modified.node._id)}}return s}function x(e,t){switch(e.opId&&d.offlineOperations.delete(e.opId),e.type){case i.DELETE_OBJECT_KEY:case i.UPDATE_OBJECT:case i.DELETE_CRDT:{const n=d.items.get(e.id);return null==n?{modified:!1}:n._apply(e,t)}case i.SET_PARENT_KEY:{const t=d.items.get(e.id);if(null==t)return{modified:!1};if(t._parent instanceof f){const n=t._parentKey;return n===e.parentKey?{modified:!1}:t._parent._setChildKey(e.parentKey,t,n)}return{modified:!1}}case i.CREATE_OBJECT:case i.CREATE_LIST:case i.CREATE_MAP:case i.CREATE_REGISTER:{const n=d.items.get(e.parentId);return null==n?{modified:!1}:n._attachChild(e,t)}}}function z(){if("closed"!==d.connection.state&&"unavailable"!==d.connection.state)return null;const e=function(e,t){if("public"===e.type){if("undefined"==typeof window&&null==t)throw new Error("To use Liveblocks client in a non-dom environment with a publicApiKey, you need to provide a fetch polyfill.");return n=>U(t||fetch,e.url,{room:n,publicApiKey:e.publicApiKey})}if("private"===e.type){if("undefined"==typeof window&&null==t)throw new Error("To use Liveblocks client in a non-dom environment with a url as auth endpoint, you need to provide a fetch polyfill.");return n=>U(t||fetch,e.url,{room:n})}if("custom"===e.type)return e.callback;throw new Error("Internal error. Unexpected authentication type")}(u.authentication,u.fetchPolyfill),t=function(e,t){if("undefined"==typeof window&&null==t)throw new Error("To use Liveblocks client in a non-dom environment, you need to provide a WebSocket polyfill.");const n=t||WebSocket;return t=>new n(`${e}/?token=${t}`)}(u.liveblocksServer,u.WebSocketPolyfill);X({state:"authenticating"}),h.authenticate(e,t)}function H(e,t){t.addEventListener("message",V),t.addEventListener("open",Z),t.addEventListener("close",W),t.addEventListener("error",Q),X({state:"connecting",id:e.actor,userInfo:e.info,userId:e.id}),d.idFactory=function(e){let t=0;return()=>`${e}:${t++}`}(e.actor),d.socket=t}function J(e){const t=d.users[e.actor];if(void 0!==e.targetActor||null==t||t._hasReceivedInitialPresence)return d.users[e.actor]=null==t?{connectionId:e.actor,presence:e.data,_hasReceivedInitialPresence:!0}:{id:t.id,info:t.info,connectionId:e.actor,presence:Object.assign(Object.assign({},t.presence),e.data),_hasReceivedInitialPresence:!0},{type:"update",updates:e.data,user:d.users[e.actor]}}function j(e){const t=e,n=d.users[t.actor];return n?(delete d.users[t.actor],{type:"leave",user:n}):null}function $(e){const t={};for(const n in e.users){const i=Number.parseInt(n),s=e.users[n];t[i]={connectionId:i,info:s.info,id:s.id}}return d.users=t,{type:"reset"}}function G(e){for(const t of d.listeners.event)t({connectionId:e.actor,event:e.event})}function F(e){return d.users[e.actor]={connectionId:e.actor,info:e.info,id:e.id,_hasReceivedInitialPresence:!0},d.me&&(d.buffer.messages.push({type:t.UPDATE_PRESENCE,data:d.me,targetActor:e.actor}),se()),{type:"enter",user:d.users[e.actor]}}function Y(e){return c(e)?e:null}function V(t){if("pong"===t.data)return void clearTimeout(d.timeoutHandles.pongTimeout);const n=function(e){const t=S(e);return void 0===t?null:a(t)?T(t.map((e=>Y(e)))):T([Y(t)])}(t.data);if(null===n||0===n.length)return;const i={storageUpdates:new Map,others:[]};for(const t of n)switch(t.type){case e.USER_JOINED:i.others.push(F(t));break;case e.UPDATE_PRESENCE:{const e=J(t);e&&i.others.push(e);break}case e.BROADCASTED_EVENT:G(t);break;case e.USER_LEFT:{const e=j(t);e&&i.others.push(e);break}case e.ROOM_STATE:i.others.push($(t));break;case e.INITIAL_STORAGE_STATE:{const e=new Map(d.offlineOperations);_(t),ie(e),null==ce||ce();break}case e.UPDATE_STORAGE:B(t.ops,!1).updates.storageUpdates.forEach(((e,t)=>{i.storageUpdates.set(t,C(i.storageUpdates.get(t),e))}))}I(i)}function W(e){if(d.socket=null,clearTimeout(d.timeoutHandles.pongTimeout),clearInterval(d.intervalHandles.heartbeat),d.timeoutHandles.flush&&clearTimeout(d.timeoutHandles.flush),clearTimeout(d.timeoutHandles.reconnect),d.users={},I({others:[{type:"reset"}]}),e.code>=4e3&&e.code<=4100){X({state:"failed"});const t=new K(e.reason,e.code);for(const e of d.listeners.error)e(t);const n=q(!0);d.numberOfRetry++,X({state:"unavailable"}),d.timeoutHandles.reconnect=h.scheduleReconnect(n)}else if(e.code===s.CLOSE_WITHOUT_RETRY)X({state:"closed"});else{const e=q();d.numberOfRetry++,X({state:"unavailable"}),d.timeoutHandles.reconnect=h.scheduleReconnect(e)}}function X(e){d.connection=e;for(const t of d.listeners.connection)t(e.state)}function q(e=!1){return e?k[d.numberOfRetry<k.length?d.numberOfRetry:k.length-1]:L[d.numberOfRetry<L.length?d.numberOfRetry:L.length-1]}function Q(){}function Z(){clearInterval(d.intervalHandles.heartbeat),d.intervalHandles.heartbeat=h.startHeartbeatInterval(),"connecting"===d.connection.state&&(X(Object.assign(Object.assign({},d.connection),{state:"open"})),d.numberOfRetry=0,void 0!==d.lastConnectionId&&(d.buffer.presence=d.me,se()),d.lastConnectionId=d.connection.id,d.root&&d.buffer.messages.push({type:t.FETCH_STORAGE}),se())}function ee(){null!=d.socket&&(clearTimeout(d.timeoutHandles.pongTimeout),d.timeoutHandles.pongTimeout=h.schedulePongTimeout(),d.socket.readyState===d.socket.OPEN&&d.socket.send("ping"))}function te(){ne()}function ne(){d.socket&&(d.socket.removeEventListener("open",Z),d.socket.removeEventListener("message",V),d.socket.removeEventListener("close",W),d.socket.removeEventListener("error",Q),d.socket.close(),d.socket=null),X({state:"unavailable"}),clearTimeout(d.timeoutHandles.pongTimeout),d.timeoutHandles.flush&&clearTimeout(d.timeoutHandles.flush),clearTimeout(d.timeoutHandles.reconnect),clearInterval(d.intervalHandles.heartbeat),z()}function ie(e){if(0===e.size)return;const n=[],i=Array.from(e.values()),s=B(i,!0);n.push({type:t.UPDATE_STORAGE,ops:i}),I(s.updates),h.send(n)}function se(){const e=d.buffer.storageOperations;if(e.length>0&&e.forEach((e=>{d.offlineOperations.set(e.opId,e)})),null==d.socket||d.socket.readyState!==d.socket.OPEN)return void(d.buffer.storageOperations=[]);const n=Date.now();if(n-d.lastFlushTime>u.throttleDelay){const e=function(e){const n=[];e.buffer.presence&&n.push({type:t.UPDATE_PRESENCE,data:e.buffer.presence});for(const t of e.buffer.messages)n.push(t);return e.buffer.storageOperations.length>0&&n.push({type:t.UPDATE_STORAGE,ops:e.buffer.storageOperations}),n}(d);if(0===e.length)return;h.send(e),d.buffer={messages:[],storageOperations:[],presence:null},d.lastFlushTime=n}else null!=d.timeoutHandles.flush&&clearTimeout(d.timeoutHandles.flush),d.timeoutHandles.flush=h.delayFlush(u.throttleDelay-(n-d.lastFlushTime))}function oe(){return d.me}function re(e){d.buffer.storageOperations.push(...e),se()}let ae=null,ce=null;return{onClose:W,onMessage:V,authenticationSuccess:H,heartbeat:ee,onNavigatorOnline:function(){"unavailable"===d.connection.state&&ne()},simulateSocketClose:function(){d.socket&&d.socket.close()},simulateSendCloseEvent:function(e){d.socket&&W(e)},onVisibilityChange:function(e){"visible"===e&&"open"===d.connection.state&&ee()},getUndoStack:()=>d.undoStack,getItemsCount:()=>d.items.size,connect:z,disconnect:function(){d.socket&&(d.socket.removeEventListener("open",Z),d.socket.removeEventListener("message",V),d.socket.removeEventListener("close",W),d.socket.removeEventListener("error",Q),d.socket.close(),d.socket=null),X({state:"closed"}),d.timeoutHandles.flush&&clearTimeout(d.timeoutHandles.flush),clearTimeout(d.timeoutHandles.reconnect),clearTimeout(d.timeoutHandles.pongTimeout),clearInterval(d.intervalHandles.heartbeat),d.users={},I({others:[{type:"reset"}]}),function(){for(const e in d.listeners)d.listeners[e]=[]}()},subscribe:function(e,t,n){if(e instanceof r)return function(e,t,n){return p((i=>{const s=[];for(const o of i)(null==n?void 0:n.isDeep)&&v(o.node,e)?s.push(o):o.node._id===e._id&&t(o.node);(null==n?void 0:n.isDeep)&&s.length>0&&t(s)}))}(e,t,n);if("function"==typeof e)return p(e);if(!P(e))throw new Error(`"${e}" is not a valid event name`);return d.listeners[e].push(t),()=>{y(d.listeners[e],t)}},unsubscribe:function(e,t){if(console.warn("unsubscribe is depreacted and will be removed in a future version.\nuse the callback returned by subscribe instead.\nSee v0.13 release notes for more information.\n"),!P(e))throw new Error(`"${e}" is not a valid event name`);y(d.listeners[e],t)},updatePresence:function(e,t){const n={};null==d.buffer.presence&&(d.buffer.presence={});for(const t in e)d.buffer.presence[t]=e[t],n[t]=d.me[t];d.me=Object.assign(Object.assign({},d.me),e),d.isBatching?((null==t?void 0:t.addToHistory)&&d.batch.reverseOps.push({type:"presence",data:n}),d.batch.updates.presence=!0):(se(),(null==t?void 0:t.addToHistory)&&b([{type:"presence",data:n}]),I({presence:!0}))},broadcastEvent:function(e,n={shouldQueueEventIfNotReady:!1}){null==d.socket&&0==n.shouldQueueEventIfNotReady||(d.buffer.messages.push({type:t.BROADCAST_EVENT,event:e}),se())},batch:function(e){if(d.isBatching)throw new Error("batch should not be called during a batch");d.isBatching=!0;try{e()}finally{d.isBatching=!1,d.batch.reverseOps.length>0&&b(d.batch.reverseOps),d.batch.ops.length>0&&(d.redoStack=[]),d.batch.ops.length>0&&re(d.batch.ops),I(d.batch.updates),d.batch={ops:[],reverseOps:[],updates:{others:[],storageUpdates:new Map,presence:!1}},se()}},undo:function(){if(d.isBatching)throw new Error("undo is not allowed during a batch");const e=d.undoStack.pop();if(null==e)return;d.isHistoryPaused=!1;const t=B(e,!0);I(t.updates),d.redoStack.push(t.reverse);for(const t of e)"presence"!==t.type&&d.buffer.storageOperations.push(t);se()},redo:function(){if(d.isBatching)throw new Error("redo is not allowed during a batch");const e=d.redoStack.pop();if(null==e)return;d.isHistoryPaused=!1;const t=B(e,!0);I(t.updates),d.undoStack.push(t.reverse);for(const t of e)"presence"!==t.type&&d.buffer.storageOperations.push(t);se()},pauseHistory:function(){d.pausedHistory=[],d.isHistoryPaused=!0},resumeHistory:function(){d.isHistoryPaused=!1,d.pausedHistory.length>0&&b(d.pausedHistory),d.pausedHistory=[]},getStorage:function(){return d.root?new Promise((e=>e({root:d.root}))):(null==ae&&(d.buffer.messages.push({type:t.FETCH_STORAGE}),se(),ae=new Promise((e=>ce=e))),ae.then((()=>({root:d.root}))))},selectors:{getConnectionState:function(){return d.connection.state},getSelf:function(){return"open"===d.connection.state||"connecting"===d.connection.state?{connectionId:d.connection.id,id:d.connection.userId,info:d.connection.userInfo,presence:oe()}:null},getPresence:oe,getOthers:function(){return d.others}}}}(function(e,t){return{connection:{state:"closed"},token:null,lastConnectionId:null,socket:null,listeners:{event:[],others:[],"my-presence":[],error:[],connection:[],storage:[]},numberOfRetry:0,lastFlushTime:0,timeoutHandles:{flush:null,reconnect:0,pongTimeout:0},buffer:{presence:null==e?{}:e,messages:[],storageOperations:[]},intervalHandles:{heartbeat:0},me:null==e?{}:e,users:{},others:D({}),defaultStorageRoot:t,idFactory:null,clock:0,opClock:0,items:new Map,root:void 0,undoStack:[],redoStack:[],isHistoryPaused:!1,pausedHistory:[],isBatching:!1,batch:{ops:[],updates:{storageUpdates:new Map,presence:!1,others:[]},reverseOps:[]},offlineOperations:new Map}}("function"==typeof p?p(u.roomId):p,"function"==typeof _?_(u.roomId):_),u),m={id:u.roomId,getConnectionState:E.selectors.getConnectionState,getSelf:E.selectors.getSelf,subscribe:E.subscribe,unsubscribe:E.unsubscribe,getPresence:E.selectors.getPresence,updatePresence:E.updatePresence,getOthers:E.selectors.getOthers,broadcastEvent:E.broadcastEvent,getStorage:E.getStorage,batch:E.batch,history:{undo:E.undo,redo:E.redo,pause:E.pauseHistory,resume:E.resumeHistory},internalDevTools:{closeWebsocket:E.simulateSocketClose,sendCloseEvent:E.simulateSendCloseEvent}};return{connect:E.connect,disconnect:E.disconnect,onNavigatorOnline:E.onNavigatorOnline,onVisibilityChange:E.onVisibilityChange,room:m}}({initialPresence:p.initialPresence,initialStorage:p.initialStorage,defaultPresence:p.defaultPresence,defaultStorageRoot:p.defaultStorageRoot},{roomId:d,throttleDelay:l,WebSocketPolyfill:u.WebSocketPolyfill,fetchPolyfill:u.fetchPolyfill,liveblocksServer:u.liveblocksServer||"wss://liveblocks.net/v5",authentication:x(u)}),h.set(d,_),p.DO_NOT_USE_withoutConnecting||_.connect()),_.room},leave:function(e){const t=h.get(e);t&&(t.disconnect(),h.delete(e))}}}function x(e){if("string"==typeof e.publicApiKey)return{type:"public",publicApiKey:e.publicApiKey,url:e.publicAuthorizeEndpoint||"https://liveblocks.io/api/public/authorize"};if("string"==typeof e.authEndpoint)return{type:"private",url:e.authEndpoint};if("function"==typeof e.authEndpoint)return{type:"custom",callback:e.authEndpoint};throw new Error("Invalid Liveblocks client options. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient")}let z=[],H=[],J=0,j=0,$={},G={},F=new Set;window.connectToRoom=async(e,t,n,i)=>{const s=B({publicApiKey:"pk_live_uRo96jE67mE0Kw3lJdu0JhAH"}).enter("liveblocks-rtt-eval",{initialStorage:{status:new A,request:new A,response:new A}}),{root:o}=await s.getStorage();let r=o.get("status"),a=o.get("request"),c=o.get("response");s.subscribe(r,(n=>{for(const i in n.toObject())z.includes(i)||(J++,z.push(i),console.log(`Peer ${i} is READY. Number of peers: ${J}`),J===t&&(console.log("All peers are READY"),a.set(e,(new Date).getTime())))})),s.subscribe(a,(t=>{const n=t.toObject();for(const t in n)t!==e&&(!$.hasOwnProperty(t)||$[t]!==n[t])&&($[t]=n[t],c.set(`${e}->${t}`,(new Date).getTime()))})),s.subscribe(c,(s=>{const o=s.toObject();for(const s in o){const r=s.split("->")[0],c=s.split("->")[1];if(c===e&&(!G.hasOwnProperty(s)||G[s]!==o[s])){const d=(new Date).getTime()-a.get(c);G[s]=o[s],H.push([d]),F.add(r),F.size===t-1&&(j++,F.clear(),console.log(`${j} out of ${n} trials done`),j<n?a.set(e,(new Date).getTime()):(console.log("RTT results are complete."),i(H)))}}})),console.log(`My ID: ${e}`),r.set(e,"READY")}})();